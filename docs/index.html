<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>❄️ Unfreeze D.C. ❄️</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    html, body {
      height: 100%;
      margin: 0;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0,0,0,0.08);
      background: rgba(255,255,255,0.86);
      backdrop-filter: blur(8px);
      box-shadow: 0 2px 10px rgba(0,0,0,0.06);
    }

    h1 {
      font-size: 18px;
      margin: 0 0 4px;
    }

    #map {
      flex: 1;
      min-height: 0; /* critical: prevents “mystery whitespace” at bottom */
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .small {
      font-size: 13px;
      color: #555;
    }

    label {
      font-size: 13px;
      color: #222;
      white-space: nowrap;
    }

    select, input[type="checkbox"] {
      margin-left: 6px;
    }

    input[type="range"] {
      width: 240px;
    }

    button {
      font-size: 12px;
      padding: 4px 8px;
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 8px;
      background: rgba(255,255,255,0.9);
      cursor: pointer;
    }

    button:hover {
      background: rgba(255,255,255,1);
    }

    .pill {
      padding: 2px 8px;
      border: 1px solid #ddd;
      border-radius: 999px;
      font-size: 12px;
      color: #333;
      background: #fafafa;
      white-space: nowrap;
    }

    .legend {
      background: rgba(255,255,255,0.88);
      padding: 8px 10px;
      border: 1px solid rgba(0,0,0,0.12);
      border-radius: 8px;
      font-size: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.08);
    }

    .swatch {
      display: inline-block;
      width: 12px;
      height: 12px;
      vertical-align: middle;
      margin-right: 6px;
      border: 1px solid #bbb;
    }

    /* --- floating layout overrides (map fills viewport; UI/legend float) --- */
    #app { flex: 1; min-height: 0; height: 100%; }
    #mapWrap { position: relative; height: 100%; }
    #map { position: absolute; inset: 0; width: 100%; height: 100%; flex: none; }

    .panel {
      background: rgba(255,255,255,0.82);
      backdrop-filter: blur(7px);
      border: 1px solid rgba(0,0,0,0.10);
      border-radius: 12px;
      box-shadow: 0 4px 18px rgba(0,0,0,0.10);
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      max-width: 1200px;
      padding: 10px 12px;
      z-index: 1000;
    }

    .uiTop {
      display: flex;
      align-items: baseline;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 6px;
    }

    .title {
      font-size: 18px;
      font-weight: 700;
    }

    #legend {
      position: absolute;
      right: 10px;
      bottom: 10px;
      z-index: 1000;
      max-width: 260px;
      max-height: 40vh;
      overflow: auto;
    }

  </style>
</head>
<body>
  <div id="app">
    <div id="mapWrap">
      <div id="map"></div>

      <!-- Floating controls panel (replaces the old <header>) -->
      <div id="ui" class="panel">
        <div class="uiTop">
          <div class="title">DC311 Snow Dashboard</div>
          <div class="row small" id="meta">Loading…</div>
        </div>

        <div class="row" style="margin-top:8px;">
          <label>Choropleth:
            <select id="geo">
              <option value="none">None</option>
              <option value="wards" selected>Wards</option>
              <option value="ancs">ANCs</option>
              <option value="clusters">Neighborhood Clusters</option>
              <option value="planning_areas">Planning Areas</option>
              <option value="tracts">Census Tracts</option>
            </select>
          </label>

          <label>Metric:
            <select id="metric">
              <option value="median_ttc_hours" selected>Median time-to-close (hrs)</option>
              <option value="mean_ttc_hours">Mean time-to-close (hrs)</option>
              <option value="pct_closed">% closed</option>
              <option value="open">Open count</option>
              <option value="total">Total requests</option>
            </select>
          </label>

          <label class="pill">
            <input type="checkbox" id="showPoints" checked />
            Show points
          </label>

          <label class="pill">
            <input type="checkbox" id="showRoutes" />
            Snow routes
          </label>

          <span class="pill" id="countPill">Points: —</span>
        </div>

        <div class="row" style="margin-top:8px;">
          <label>From:
            <input type="range" id="start" />
            <span class="small" id="startLabel">—</span>
          </label>
          <label>To:
            <input type="range" id="end" />
            <span class="small" id="endLabel">—</span>
          </label>

          <!-- optional: if you already wired these in JS, keep them; otherwise delete -->
          <button id="stormPreset" type="button">Storm preset (since Jan 24)</button>
          <button id="fullRange" type="button">Full range</button>
        </div>
      </div>

      <!-- Floating legend (always visible; JS fills contents) -->
      <div id="legend" class="legend panel"></div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // ---- helpers
    const fmtDT = (ms) => {
      const d = new Date(ms);
      return d.toLocaleString(undefined, { year:"numeric", month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit" });
    };
    const isNum = (x) => typeof x === "number" && isFinite(x);

    function median(arr) {
      if (!arr.length) return null;
      arr.sort((a,b)=>a-b);
      const m = Math.floor(arr.length/2);
      return arr.length % 2 ? arr[m] : (arr[m-1] + arr[m]) / 2;
    }
    function mean(arr) {
      if (!arr.length) return null;
      let s = 0;
      for (const v of arr) s += v;
      return s / arr.length;
    }

    function ramp(t) {
      const colors = ["#f7fbff","#deebf7","#c6dbef","#9ecae1","#6baed6","#2171b5"];
      t = Math.max(0, Math.min(1, t));
      return colors[Math.min(colors.length - 1, Math.floor(t * colors.length))];
    }

    function metricLabel(metric) {
      return {
        median_ttc_hours: "Median time-to-close (hrs)",
        mean_ttc_hours: "Mean time-to-close (hrs)",
        pct_closed: "% closed",
        open: "Open count",
        total: "Total requests",
      }[metric] ?? metric;
    }

    function metricValue(m, metric) {
      if (!m) return null;
      if (metric === "pct_closed") return isNum(m.pct_closed) ? m.pct_closed * 100 : null;
      return m[metric];
    }

    function computeMetrics(points, keyField) {
      const groups = new Map();

      for (const f of points) {
        const p = f.properties || {};
        const k = p[keyField];
        if (!k) continue;

        let g = groups.get(k);
        if (!g) {
          g = { total:0, open:0, closed:0, pct_closed:null,
                median_ttc_hours:null, mean_ttc_hours:null, median_open_age_hours:null,
                _ttc:[], _age:[] };
          groups.set(k, g);
        }

        g.total += 1;

        if (p.closed === true) {
          g.closed += 1;
          if (isNum(p.ttc_hours)) g._ttc.push(p.ttc_hours);
        } else {
          g.open += 1;
          if (isNum(p.open_age_hours)) g._age.push(p.open_age_hours);
        }
      }

      const out = {};
      for (const [k, g] of groups.entries()) {
        g.pct_closed = g.total ? (g.closed / g.total) : null;
        g.median_ttc_hours = median(g._ttc);
        g.mean_ttc_hours = mean(g._ttc);
        g.median_open_age_hours = median(g._age);
        delete g._ttc; delete g._age;
        out[String(k)] = g;
      }
      return out;
    }


    function legendControl() {
      const div = L.DomUtil.create('div', 'legend');
      div.innerHTML = `<div><strong>Legend</strong></div><div class="small" id="legendMetric"></div><div id="legendRamp"></div>`;
      return div;
    }

    // ---- map init
    const map = L.map('map', { preferCanvas: true }).setView([38.9072, -77.0369], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    map.createPane("routesPane");
    map.getPane("routesPane").style.zIndex = 350;

    map.createPane("choroPane");
    map.getPane("choroPane").style.zIndex = 400;

    map.createPane("pointsPane");
    map.getPane("pointsPane").style.zIndex = 450;

    map.getPane("tooltipPane").style.zIndex = 1200;
    map.getPane("popupPane").style.zIndex = 1200;

    const legendHost = document.getElementById("legend");
    if (legendHost) {
      legendHost.innerHTML = `<div><strong>Legend</strong></div><div class="small" id="legendMetric"></div><div id="legendRamp"></div>`;
    }

    let allPointsFC = null;
    let wardsBase = null;
    let ancsBase = null;
    let clustersBase = null;
    let planningBase = null;
    let tractsBase = null;
    let routesFC = null;
    let pops = null;

    let pointsLayer = null;
    let choroLayer = null;

    let routesLayer = null;

    function routeStyle(feature) {
      const t = feature?.properties?.ROUTETYPE;
      if (t === 'Primary')   return { color:'#444', weight:3, opacity:0.65 };
      if (t === 'Secondary') return { color:'#666', weight:2, opacity:0.55, dashArray:'6 6' };
      return { color:'#888', weight:1.2, opacity:0.35 };
    }

    function ensureRoutesLayer() {
      if (!routesFC || routesLayer) return;
      routesLayer = L.geoJSON(routesFC, {
        pane: 'routesPane',
        interactive: false,
        style: routeStyle
      });
    }

    function updateRoutes() {
      if (!map) return;
      if (!showRoutes.checked) {
        if (routesLayer && map.hasLayer(routesLayer)) map.removeLayer(routesLayer);
        return;
      }
      ensureRoutesLayer();
      if (routesLayer && !map.hasLayer(routesLayer)) routesLayer.addTo(map);
    }

    // ---- UI elements
    const geoSel = document.getElementById("geo");
    const metricSel = document.getElementById("metric");
    const showPoints = document.getElementById("showPoints");
    const showRoutes = document.getElementById("showRoutes");
    const startSlider = document.getElementById("start");
    const endSlider = document.getElementById("end");
    const startLabel = document.getElementById("startLabel");
    const endLabel = document.getElementById("endLabel");
    const countPill = document.getElementById("countPill");

    function setMeta(j) {
      document.getElementById("meta").textContent =
        `Last refresh (UTC): ${j.last_refresh_utc} · Records: ${j.records}`;
    }

    function clampSliders() {
      const a = Number(startSlider.value);
      const b = Number(endSlider.value);
      if (a > b) {
        // keep the one being moved “winning” by snapping the other
        endSlider.value = startSlider.value;
      }
    }

    function filteredPoints() {
      const a = Number(startSlider.value);
      const b = Number(endSlider.value);
      const feats = allPointsFC.features.filter(f => {
        const t = f.properties?.add_ms;
        return typeof t === "number" && t >= a && t <= b;
      });
      return feats;
    }

    function updatePointLayer(feats) {
      if (pointsLayer) pointsLayer.remove();

      if (!showPoints.checked) {
        pointsLayer = null;
        return;
      }

      const fc = { type: "FeatureCollection", features: feats };

      pointsLayer = L.geoJSON(fc, {
        pane: "pointsPane",
        interactive: true,
      
        pointToLayer: (feature, latlng) => {
          const closed = feature.properties?.closed === true;
          return L.circleMarker(latlng, {
            radius: 4,
            weight: 0.5,
            opacity: 0.8,
            fillOpacity: 0.7,
            fillColor: closed ? "#2ca02c" : "#d62728",
            color: "#222",
            interactive: true
          });
        },
      
        onEachFeature: (feature, layer) => {
          const p = feature.properties || {};
          const status  = p.SERVICEORDERSTATUS ?? (p.closed ? "Closed" : "Open");
          const created = (typeof p.add_ms === "number") ? fmtDT(p.add_ms) : "—";
          const resolved = (typeof p.res_ms === "number") ? fmtDT(p.res_ms) : "—";
          const ward = p.WARD ?? "—";
          const anc  = p.ANC_ID ?? "—";
          const addr = p.STREETADDRESS ?? "";
          const desc = p.SERVICECODEDESCRIPTION ?? "";
      
          layer.bindPopup(
            `<strong>${status}</strong><br/>
             ${desc}<br/>
             ${addr ? addr + "<br/>" : ""}
             Ward: ${ward}<br/>
             ANC: ${anc}<br/>
             Created: ${created}<br/>
             Resolved: ${resolved}`
          );
      
          // Tooltip: only show for points when choropleth is OFF (geo = "none")
          layer.unbindTooltip();
          if (geoSel.value === "none") {
            const tipDesc = (desc || "").trim();
            const tipAddr = (addr || "").trim();
            const mid = [tipDesc, tipAddr].filter(Boolean).join("<br/>");
      
            layer.bindTooltip(
              `<strong>${status}</strong>${mid ? "<br/>" + mid : ""}<br/>Created: ${created}<br/>Resolved: ${resolved}`,
              { sticky: true, direction: "top", opacity: 0.95 }
            );
          }
        }
      }).addTo(map);pointsLayer = L.geoJSON(fc, {
        pane: "pointsPane",
        interactive: true,
        pointToLayer: (feature, latlng) => {
          const closed = feature.properties?.closed === true;
          return L.circleMarker(latlng, {
            radius: 4,
            weight: 0.5,
            opacity: 0.8,
            fillOpacity: 0.7,
            // simple status styling
            fillColor: closed ? "#2ca02c" : "#d62728",
            color: "#222",
            interactive: true
          });
        },
        onEachFeature: (feature, layer) => {
          const p = feature.properties || {};
          const status  = p.SERVICEORDERSTATUS ?? (p.closed ? "Closed" : "Open");
          const created = (typeof p.add_ms === "number") ? fmtDT(p.add_ms) : "—";
          const resolved = (typeof p.res_ms === "number") ? fmtDT(p.res_ms) : "—";
          const ward = p.WARD ?? "—";
          const anc  = p.ANC_ID ?? "—";
          const addr = p.STREETADDRESS ?? "";
          const desc = p.SERVICECODEDESCRIPTION ?? "";
        
          // ✅ Popup: pass ONE string argument, then close the call
          layer.bindPopup(
            `<strong>${status}</strong><br/>
             ${desc}<br/>
             ${addr ? addr + "<br/>" : ""}
             Ward: ${ward}<br/>
             ANC: ${anc}<br/>
             Created: ${created}<br/>
             Resolved: ${resolved}`
          );
        
          // ✅ Tooltip: only when choropleth is OFF (geo = "none")
          layer.unbindTooltip();
          if (geoSel.value === "none") {
            const tipDesc = (desc || "").trim();
            const tipAddr = (addr || "").trim();
            const mid = [tipDesc, tipAddr].filter(Boolean).join("<br/>");
        
            layer.bindTooltip(
              `<strong>${status}</strong>${mid ? "<br/>" + mid : ""}<br/>Created: ${created}<br/>Resolved: ${resolved}`,
              { sticky: true, direction: "top", opacity: 0.95 }
            );
          }
        }
          layer.unbindTooltip();
          if (geoSel.value === "none") {
            layer.bindTooltip(
              `<strong>${status}</strong><br/>Created: ${created}<br/>Resolved: ${resolved}`,
              { sticky: true, direction: "top", opacity: 0.95 }
            );
          }

        }
      }).addTo(map);
    }

    function updateLegend(metric, min, max) {
      document.getElementById("legendMetric").textContent = metricLabel(metric);

      const rampDiv = document.getElementById("legendRamp");
      rampDiv.innerHTML = "";
      const steps = 6;

      for (let i = 0; i < steps; i++) {
        const t0 = i / steps;
        const t1 = (i+1) / steps;
        const sw = document.createElement("div");
        sw.innerHTML = `<span class="swatch" style="background:${ramp((t0+t1)/2)}"></span>
                        <span>${(min + (max-min)*t0).toFixed(1)}–${(min + (max-min)*t1).toFixed(1)}</span>`;
        rampDiv.appendChild(sw);
      }
    }

    function updateChoropleth(feats) {
      if (choroLayer) choroLayer.remove();
      choroLayer = null;

      const geo = geoSel.value;
      if (geo === "none") return;

      const metric = metricSel.value;

      let base = null;
      let keyField = null;
      let pointsKey = null;

      if (geo === "wards") {
        base = wardsBase; keyField = "WARD"; pointsKey = "WARD";
      } else if (geo === "ancs") {
        base = ancsBase; keyField = "ANC_ID"; pointsKey = "ANC_ID";
      } else if (geo === "clusters") {
        base = clustersBase; keyField = "CLUSTER"; pointsKey = "CLUSTER";
      } else if (geo === "planning_areas") {
        base = planningBase; keyField = "PLANNING_AREA"; pointsKey = "PLANNING_AREA";
      } else if (geo === "tracts") {
        base = tractsBase; keyField = "TRACT"; pointsKey = "TRACT";
      }

      if (!base) return;

      const mm = computeMetrics(feats, pointsKey);

      // build a fresh copy so we can overwrite properties cleanly
      const gj = JSON.parse(JSON.stringify(base));

      // attach computed metrics to polygon props
      for (const ft of gj.features) {
        ft.properties = ft.properties || {};

        // primary match: the intended keyField
        const k0 = ft.properties[keyField];

        // fallback match: NAME (helps if your source polygons only have NAME)
        const k1 = ft.properties.NAME;

        const m =
          (k0 != null && mm[String(k0)]) ? mm[String(k0)] :
          (k1 != null && mm[String(k1)]) ? mm[String(k1)] :
          null;

        ft.properties._m = m;
      }

      // compute min/max for styling
      const vals = [];
      for (const ft of gj.features) {
        const v = metricValue(ft.properties._m, metric);
        if (isNum(v)) vals.push(v);
      }
      const min = vals.length ? Math.min(...vals) : 0;
      const max = vals.length ? Math.max(...vals) : 1;

      choroLayer = L.geoJSON(gj, {
        pane: "choroPane",
        style: (feature) => {
          const v = metricValue(feature.properties?._m, metric);
          let fill = "#eee";
          if (isNum(v) && max > min) fill = ramp((v - min) / (max - min));
          return { color: "#333", weight: 1, fillColor: fill, fillOpacity: 0.75 };
        },
        onEachFeature: (feature, layer) => {
          const p = feature.properties || {};
          const m = p._m;

          let name = "";
          if (geo === "wards") name = `Ward ${p.WARD}`;
          else if (geo === "ancs") name = `ANC ${p.ANC_ID}`;
          else if (geo === "clusters") name = `Cluster: ${p.CLUSTER ?? p.NAME ?? "—"}`;
          else if (geo === "planning_areas") name = `Planning area: ${p.PLANNING_AREA ?? p.NAME ?? "—"}`;
          else if (geo === "tracts") name = `Tract ${p.TRACT ?? p.NAME ?? "—"}`;

          const v = metricValue(m, metric);
          const shown = (metric === "pct_closed" && isNum(v)) ? `${v.toFixed(1)}%`
                      : (isNum(v) ? v.toFixed(1) : "n/a");

          const total = m?.total ?? 0;
          const open = m?.open ?? 0;
          const closed = m?.closed ?? 0;

          layer.bindPopup(
            `<strong>${name}</strong><br/>
             ${metricLabel(metric)}: ${shown}<br/>
             Total: ${total} · Open: ${open} · Closed: ${closed}`
          );

          layer.bindTooltip(
            `<strong>${name}</strong><br/>
             ${metricLabel(metric)}: ${shown}`,
            { sticky: true, direction: "top", opacity: 0.95 }
          );

        }
      }).addTo(map);

      updateLegend(metric, min, max);
    }

    const stormPresetBtn = document.getElementById("stormPreset");
    const fullRangeBtn = document.getElementById("fullRange");

    // debounce for slider drags
    let timer = null;
    function recompute() {
      clearTimeout(timer);
      timer = setTimeout(() => {
        clampSliders();
        const feats = filteredPoints();
        countPill.textContent = `Points: ${feats.length.toLocaleString()} / ${allPointsFC.features.length.toLocaleString()}`;
        startLabel.textContent = fmtDT(Number(startSlider.value));
        endLabel.textContent = fmtDT(Number(endSlider.value));
        updatePointLayer(feats);
        updateChoropleth(feats);
      }, 75);
    }

    async function boot() {
      const refresh = await fetch("./data/last_refresh.json").then(r => r.json());
      setMeta(refresh);

      pops = await fetch("./data/populations.json").then(r => r.json()).catch(() => null);

      allPointsFC = await fetch("./data/points.geojson").then(r => r.json());
      wardsBase = await fetch("./data/choropleth_wards.geojson").then(r => r.json());
      ancsBase = await fetch("./data/choropleth_ancs.geojson").then(r => r.json());
      clustersBase = await fetch("./data/choropleth_clusters.geojson").then(r => r.json());
      planningBase = await fetch("./data/choropleth_planning_areas.geojson").then(r => r.json());
      tractsBase = await fetch("./data/choropleth_tracts.geojson").then(r => r.json());
      routesFC = await fetch("./data/snow_routes.geojson").then(r => r.json()).catch(() => null);

      // slider range = min/max add_ms across points
      const times = allPointsFC.features
        .map(f => f.properties?.add_ms)
        .filter(t => typeof t === "number" && isFinite(t));

      const minT = Math.min(...times);
      const maxT = Math.max(...times);

      // use hour steps
      const STEP = 3600 * 1000;

      startSlider.min = String(minT);
      startSlider.max = String(maxT);
      startSlider.step = String(STEP);
      startSlider.value = String(minT);

      endSlider.min = String(minT);
      endSlider.max = String(maxT);
      endSlider.step = String(STEP);
      endSlider.value = String(maxT);

      // initial render
      recompute();

      // wire UI
      startSlider.addEventListener("input", recompute);
      endSlider.addEventListener("input", recompute);
      geoSel.addEventListener("change", recompute);
      metricSel.addEventListener("change", recompute);
      showPoints.addEventListener("change", recompute);
      showRoutes.addEventListener("change", () => { updateRoutes(); });
    }

    function applyRange(a, b) {
      startSlider.value = String(a);
      endSlider.value = String(b);
      recompute();
    }

    stormPresetBtn?.addEventListener("click", () => {
      // Jan 24 of the year matching your data max timestamp
      const dMax = new Date(Number(endSlider.max || Date.now()));
      const stormStart = new Date(dMax.getFullYear(), 0, 24, 0, 0, 0).getTime();
      applyRange(Math.max(Number(startSlider.min), stormStart), Number(endSlider.max));
    });

    fullRangeBtn?.addEventListener("click", () => {
      applyRange(Number(startSlider.min), Number(endSlider.max));
    });

    boot().catch(err => {
      document.getElementById("meta").textContent = "Failed to load data files. Check docs/data outputs.";
      console.error(err);
    });
  </script>
</body>
</html>
