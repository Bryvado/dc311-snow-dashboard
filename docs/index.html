<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DC311 Snow Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header { padding: 12px 14px; border-bottom: 1px solid #eee; background: #fff; }
    h1 { font-size: 20px; margin: 0 0 6px; }
    #map { height: calc(100vh - 215px); }

    .row { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
    .small { font-size: 13px; color:#555; }
    label { font-size: 13px; color:#222; }
    select, input[type="checkbox"] { margin-left: 6px; }
    input[type="range"] { width: 240px; }

    .pill { padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; color:#333; background:#fafafa; }
    .btn { cursor:pointer; user-select:none; }
    .err { color:#b00020; font-weight: 600; }

    details.legend { border: 1px solid #ddd; border-radius: 10px; padding: 6px 10px; background:#fff; }
    details.legend > summary { cursor: pointer; font-size: 12px; font-weight: 700; }
    .legendGrid { display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top:8px; }
    .legendSectionTitle { font-weight:700; margin-bottom:4px; font-size:12px; }
    .muted { color:#666; font-size:12px; }
    .swatch { display:inline-block; width:12px; height:12px; vertical-align:middle; margin-right:6px; border:1px solid #bbb; }
    .legendRow { display:flex; align-items:center; gap:10px; flex-wrap:wrap; font-size:12px; }
	.legendOverlay {
	  background: rgba(255,255,255,0.78);
	  backdrop-filter: blur(2px);
	  padding: 8px 10px;
	  border: 1px solid rgba(0,0,0,0.15);
	  border-radius: 10px;
	  font-size: 12px;
	  max-width: 260px;
	  max-height: 40vh;
	  overflow: auto;
	}
	.legendOverlay .title { font-weight: 700; margin-bottom: 4px; }
	.legendOverlay .section { margin-top: 8px; }
	.legendOverlay .muted { color:#666; }
	.legendOverlay .swatch { display:inline-block; width:12px; height:12px; vertical-align:middle; margin-right:6px; border:1px solid #bbb; }
	.legendOverlay .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
  </style>
</head>
<body>
  <header>
    <h1>DC311 Snow Dashboard</h1>
    <div class="row small" id="meta">Loading…</div>

    <div class="row" style="margin-top:10px;">
      <label>Choropleth:
        <select id="geo">
          <option value="none">None</option>
          <option value="wards" selected>Wards</option>
          <option value="ancs">ANCs</option>
        </select>
      </label>

      <!-- NEW: scope first -->
      <label>Requests:
        <select id="scope">
          <option value="both" selected>Open + Resolved</option>
          <option value="open">Open only</option>
          <option value="resolved">Resolved only</option>
        </select>
      </label>

      <!-- Metric gets populated based on scope -->
      <label>Metric:
        <select id="metric"></select>
      </label>

      <label class="pill">
        <input type="checkbox" id="showChoro" checked />
        Show choropleth
      </label>

      <span class="pill">
        <label style="cursor:pointer;">
          <input type="checkbox" id="perPop" />
          Per 10k residents
        </label>
      </span>

      <span id="perPopErr" class="small err" style="display:none;"></span>

      <label class="pill">
        <input type="checkbox" id="showPoints" checked />
        Show points
      </label>

      <span class="pill" id="countPill">Points: —</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label>From:
        <input type="range" id="start" />
        <span class="small" id="startLabel">—</span>
      </label>

      <label>To:
        <input type="range" id="end" />
        <span class="small" id="endLabel">—</span>
      </label>

      <!-- NEW: Storm preset -->
      <span class="pill btn" id="presetStorm">Storm preset (since Jan 24)</span>
      <span class="pill btn" id="presetAll">Full range</span>
    </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // -------------------------
    // Helpers
    // -------------------------
    const fmtDT = (ms) => {
      const d = new Date(ms);
      return d.toLocaleString(undefined, { year:"numeric", month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit" });
    };
    const isNum = (x) => typeof x === "number" && isFinite(x);

    function median(arr) {
      if (!arr.length) return null;
      arr.sort((a,b)=>a-b);
      const m = Math.floor(arr.length/2);
      return arr.length % 2 ? arr[m] : (arr[m-1] + arr[m]) / 2;
    }
    function mean(arr) {
      if (!arr.length) return null;
      let s = 0;
      for (const v of arr) s += v;
      return s / arr.length;
    }

    async function fetchJson(url) {
      const r = await fetch(url, { cache: "no-store" });
      if (!r.ok) throw new Error(`${url} HTTP ${r.status}`);
      return await r.json();
    }

    // Choropleth ramp (light -> dark blue)
    function choroRamp(t) {
      const colors = ["#f7fbff","#deebf7","#c6dbef","#9ecae1","#6baed6","#2171b5"];
      t = Math.max(0, Math.min(1, t));
      return colors[Math.min(colors.length - 1, Math.floor(t * colors.length))];
    }

    // Point scale ramp (blue -> red) for time-to-close
    function rbRamp(t) {
      const colors = ["#2166ac","#67a9cf","#d1e5f0","#fddbc7","#ef8a62","#b2182b"];
      t = Math.max(0, Math.min(1, t));
      return colors[Math.min(colors.length - 1, Math.floor(t * colors.length))];
    }

    // -------------------------
    // Metric rules
    // -------------------------
    const PER_POP_METRICS = new Set(["open", "closed", "total"]);
    const TTC_METRICS = new Set(["median_ttc_hours", "mean_ttc_hours"]);

    function metricSupportsPerPop(metric) { return PER_POP_METRICS.has(metric); }
    function pointsUseTtcScale(metric) { return TTC_METRICS.has(metric); }

    const METRICS = {
      // both open + resolved in the filtered dataset
      both: [
        { value: "pct_closed", label: "% closed" },
        { value: "median_ttc_hours", label: "Median time-to-close (hrs)" },
        { value: "mean_ttc_hours", label: "Mean time-to-close (hrs)" },
        { value: "open", label: "Open count" },
        { value: "closed", label: "Closed count" },
        { value: "total", label: "Total requests" },
      ],
      // open-only dataset
      open: [
        { value: "median_open_age_hours", label: "Median open age (hrs)" },
        { value: "mean_open_age_hours", label: "Mean open age (hrs)" },
        { value: "open", label: "Open count" },
        { value: "total", label: "Total requests" },
      ],
      // resolved-only dataset
      resolved: [
        { value: "median_ttc_hours", label: "Median time-to-close (hrs)" },
        { value: "mean_ttc_hours", label: "Mean time-to-close (hrs)" },
        { value: "closed", label: "Closed count" },
        { value: "total", label: "Total requests" },
      ],
    };

    function metricLabel(metric, perPopOn) {
      const map = {
        pct_closed: "% closed",
        median_ttc_hours: "Median time-to-close (hrs)",
        mean_ttc_hours: "Mean time-to-close (hrs)",
        median_open_age_hours: "Median open age (hrs)",
        mean_open_age_hours: "Mean open age (hrs)",
        open: "Open count",
        closed: "Closed count",
        total: "Total requests",
      };
      const base = map[metric] ?? metric;
      if (perPopOn && metricSupportsPerPop(metric)) return `${base} (per 10k residents)`;
      return base;
    }

    function metricValue(m, metric, pop, perPopOn) {
      if (!m) return null;

      const derived = {
        pct_closed: () => isNum(m.pct_closed) ? (m.pct_closed * 100) : null,
        median_ttc_hours: () => m.median_ttc_hours,
        mean_ttc_hours: () => m.mean_ttc_hours,
        median_open_age_hours: () => m.median_open_age_hours,
        mean_open_age_hours: () => m.mean_open_age_hours,
      };
      if (derived[metric]) return derived[metric]();

      const v = m[metric]; // counts
      if (!perPopOn || !metricSupportsPerPop(metric)) return v;

      if (!isNum(v) || !isNum(pop) || pop <= 0) return null;
      return (v / pop) * 10000.0;
    }

    function computeMetrics(points, keyField) {
      const groups = new Map();

      for (const f of points) {
        const p = f.properties || {};
        const k = p[keyField];
        if (!k) continue;

        let g = groups.get(k);
        if (!g) {
          g = {
            total:0, open:0, closed:0, pct_closed:null,
            median_ttc_hours:null, mean_ttc_hours:null,
            median_open_age_hours:null, mean_open_age_hours:null,
            _ttc:[], _age:[]
          };
          groups.set(k, g);
        }

        g.total += 1;

        if (p.closed === true) {
          g.closed += 1;
          if (isNum(p.ttc_hours)) g._ttc.push(p.ttc_hours);
        } else {
          g.open += 1;
          if (isNum(p.open_age_hours)) g._age.push(p.open_age_hours);
        }
      }

      const out = {};
      for (const [k, g] of groups.entries()) {
        g.pct_closed = g.total ? (g.closed / g.total) : null;
        g.median_ttc_hours = median(g._ttc);
        g.mean_ttc_hours = mean(g._ttc);
        g.median_open_age_hours = median(g._age);
        g.mean_open_age_hours = mean(g._age);
        delete g._ttc; delete g._age;
        out[String(k)] = g;
      }
      return out;
    }

    // -------------------------
    // Map init
    // -------------------------
    const map = L.map('map', { preferCanvas: true }).setView([38.9072, -77.0369], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    let allPointsFC = null;
    let wardsBase = null;
    let ancsBase = null;
    let pops = null;

    let pointsLayer = null;
    let choroLayer = null;

    // -------------------------
    // UI elements
    // -------------------------
    const geoSel = document.getElementById("geo");
    const scopeSel = document.getElementById("scope");
    const metricSel = document.getElementById("metric");
    const showChoro = document.getElementById("showChoro");
    const perPop = document.getElementById("perPop");
    const perPopErr = document.getElementById("perPopErr");
    const showPoints = document.getElementById("showPoints");
    const startSlider = document.getElementById("start");
    const endSlider = document.getElementById("end");
    const startLabel = document.getElementById("startLabel");
    const endLabel = document.getElementById("endLabel");
    const countPill = document.getElementById("countPill");
    const presetStorm = document.getElementById("presetStorm");
    const presetAll = document.getElementById("presetAll");

    // Globals used by presets
    let RANGE_MIN = null, RANGE_MAX = null, RANGE_STEP = 3600 * 1000;

    function setMeta(j) {
      document.getElementById("meta").textContent =
        `Last refresh (UTC): ${j.last_refresh_utc} · Records: ${j.records}`;
    }

    function clampSliders() {
      const a = Number(startSlider.value);
      const b = Number(endSlider.value);
      if (a > b) endSlider.value = startSlider.value;
    }

    function applyScope() {
      // Populate metric options based on scope
      const scope = scopeSel.value;
      const options = METRICS[scope];

      const current = metricSel.value;
      metricSel.innerHTML = "";

      for (const o of options) {
        const opt = document.createElement("option");
        opt.value = o.value;
        opt.textContent = o.label;
        metricSel.appendChild(opt);
      }

      // Try to keep current metric if still allowed
      const stillOk = options.some(o => o.value === current);
      metricSel.value = stillOk ? current : options[0].value;

      // Clear per-pop error when scope changes
      perPopErr.style.display = "none";
      perPopErr.textContent = "";
    }

    function filteredPoints() {
      const a = Number(startSlider.value);
      const b = Number(endSlider.value);
      const scope = scopeSel.value; // both | open | resolved

      return allPointsFC.features.filter(f => {
        const p = f.properties || {};
        const t = p.add_ms;
        if (typeof t !== "number" || !isFinite(t) || t < a || t > b) return false;

        const isClosed = (p.closed === true);
        if (scope === "open" && isClosed) return false;
        if (scope === "resolved" && !isClosed) return false;

        return true;
      });
    }

    // -------------------------
    // Per-pop validation (red error message)
    // -------------------------
    function canUsePerPop() {
      const metric = metricSel.value;
      const geoOk = showChoro.checked && geoSel.value !== "none";
      return geoOk && metricSupportsPerPop(metric);
    }

    function validatePerPopToggle() {
      perPopErr.style.display = "none";
      perPopErr.textContent = "";

      if (perPop.checked && !canUsePerPop()) {
        perPop.checked = false;
        perPopErr.textContent = "Per 10k is only available for Open/Closed/Total counts with choropleth on.";
        perPopErr.style.display = "";
      }
    }

    // -------------------------
    // Points layer (auto coloring)
    // -------------------------
    function updatePointLayer(feats, ttcMin, ttcMax) {
      if (pointsLayer) pointsLayer.remove();
      if (!showPoints.checked) { pointsLayer = null; return; }

      const metric = metricSel.value;
      const useScale = pointsUseTtcScale(metric);

      const fc = { type: "FeatureCollection", features: feats };

      pointsLayer = L.geoJSON(fc, {
        pointToLayer: (feature, latlng) => {
          const p = feature.properties || {};
          const closed = p.closed === true;

          // Default: open=red, resolved=blue
          let fill = closed ? "#1f77b4" : "#d62728";

          // If metric is ttc, use blue->red scale for resolved points
          if (useScale && closed && isNum(p.ttc_hours) && isNum(ttcMin) && isNum(ttcMax) && ttcMax > ttcMin) {
            fill = rbRamp((p.ttc_hours - ttcMin) / (ttcMax - ttcMin));
          } else if (useScale && !closed) {
            fill = "#999999";
          }

          return L.circleMarker(latlng, {
            radius: 4,
            weight: 0.6,
            opacity: 0.9,
            fillOpacity: 0.75,
            fillColor: fill,
            color: "#222"
          });
        },
        onEachFeature: (feature, layer) => {
          const p = feature.properties || {};
          const created = (typeof p.add_ms === "number") ? fmtDT(p.add_ms) : "—";
          const isClosed = (p.closed === true);
          const resolvedAt = (typeof p.res_ms === "number") ? fmtDT(p.res_ms) : "—";

          const ward = p.WARD ?? "—";
          const anc = p.ANC_ID ?? "—";
          const addr = p.STREETADDRESS ?? "";
          const desc = p.SERVICECODEDESCRIPTION ?? "";
          const status = isClosed ? "Resolved" : "Open";

          const extra =
            isClosed && isNum(p.ttc_hours) ? `<br/>Time to close: ${p.ttc_hours.toFixed(1)} hrs`
            : (!isClosed && isNum(p.open_age_hours) ? `<br/>Open age: ${p.open_age_hours.toFixed(1)} hrs` : "");

          const html =
            `<strong>${status}</strong><br/>
             ${desc}<br/>
             ${addr}<br/>
             Ward ${ward} · ANC ${anc}<br/>
             Created: ${created}<br/>
             Resolved: ${isClosed ? "Yes" : "No"}${isClosed ? `<br/>Resolved at: ${resolvedAt}` : ""}${extra}`;

          layer.bindTooltip(html, { sticky: true });
          layer.bindPopup(html);
        }
      }).addTo(map);
    }

    // -------------------------
    // Choropleth layer (toggle)
    // -------------------------
    function updateChoropleth(feats) {
      if (choroLayer) choroLayer.remove();
      choroLayer = null;

      if (!showChoro.checked) return null;

      const geo = geoSel.value;
      if (geo === "none") return null;

      const metric = metricSel.value;
      const perPopOn = perPop.checked;

      const base = (geo === "wards") ? wardsBase : ancsBase;
      const keyField = (geo === "wards") ? "WARD" : "ANC_ID";
      const pointsKey = keyField;

      const popTable = (geo === "wards") ? (pops?.wards || {}) : (pops?.ancs || {});
      const mm = computeMetrics(feats, pointsKey);

      const gj = JSON.parse(JSON.stringify(base));
      for (const ft of gj.features) {
        const k = ft.properties?.[keyField];
        const id = (k != null) ? String(k) : null;

        ft.properties = ft.properties || {};
        ft.properties._m = (id && mm[id]) ? mm[id] : null;
        ft.properties._pop = (id && popTable[id] != null) ? Number(popTable[id]) : null;
      }

      const vals = [];
      for (const ft of gj.features) {
        const v = metricValue(ft.properties._m, metric, ft.properties._pop, perPopOn);
        if (isNum(v)) vals.push(v);
      }
      const min = vals.length ? Math.min(...vals) : 0;
      const max = vals.length ? Math.max(...vals) : 1;

      choroLayer = L.geoJSON(gj, {
        style: (feature) => {
          const v = metricValue(feature.properties?._m, metric, feature.properties?._pop, perPopOn);
          let fill = "#eee";
          if (isNum(v) && max > min) fill = choroRamp((v - min) / (max - min));
          return { color: "#333", weight: 1, fillColor: fill, fillOpacity: 0.75 };
        },
        onEachFeature: (feature, layer) => {
          const p = feature.properties || {};
          const m = p._m;
          const pop = p._pop;

          const name = (geo === "wards") ? `Ward ${p.WARD}` : `ANC ${p.ANC_ID}`;

          const v = metricValue(m, metric, pop, perPopOn);
          const shown = (metric === "pct_closed" && isNum(v)) ? `${v.toFixed(1)}%`
                      : (isNum(v) ? v.toFixed(1) : "n/a");

          const total = m?.total ?? 0;
          const open = m?.open ?? 0;
          const closed = m?.closed ?? 0;

          const popLine = isNum(pop) ? `Population: ${Math.round(pop).toLocaleString()}` : `Population: n/a`;

          layer.bindTooltip(
            `<strong>${name}</strong><br/>
             ${metricLabel(metric, perPopOn)}: ${shown}<br/>
             total: ${total} · open: ${open} · closed: ${closed}<br/>
             ${popLine}`,
            { sticky: true }
          );
        }
      }).addTo(map);

      return { geo, metric, perPopOn, min, max };
    }

    // -------------------------
    // Legend (compact)
    // -------------------------
    function rampBlock(rampFn, min, max, unitSuffix="") {
      const steps = 6;
      if (!isNum(min) || !isNum(max) || max <= min) return `<div class="muted">n/a</div>`;
      let html = "";
      for (let i = 0; i < steps; i++) {
        const t0 = i / steps, t1 = (i + 1) / steps, mid = (t0 + t1) / 2;
        const a = (min + (max - min) * t0).toFixed(1);
        const b = (min + (max - min) * t1).toFixed(1);
        html += `<div><span class="swatch" style="background:${rampFn(mid)}"></span><span>${a}–${b}${unitSuffix}</span></div>`;
      }
      return html;
    }

    function renderLegend({ pointMode, ttcMin, ttcMax, choroInfo }) {
      // Points legend
      let pointsLegend = "";
      if (!showPoints.checked) {
        pointsLegend = `<div class="muted">Points hidden</div>`;
      } else if (pointMode === "ttc") {
        pointsLegend =
          `<div class="muted">Resolved points colored by <strong>time to close</strong> (hrs). Open points gray.</div>
           ${rampBlock(rbRamp, ttcMin, ttcMax, " hrs")}`;
      } else {
        pointsLegend =
          `<div class="legendRow">
             <div><span class="swatch" style="background:#d62728"></span>Open</div>
             <div><span class="swatch" style="background:#1f77b4"></span>Resolved</div>
           </div>`;
      }

      // Choropleth legend
      let choroLegend = `<div class="muted">Choropleth off</div>`;
      if (choroInfo && showChoro.checked && geoSel.value !== "none") {
        const lbl = metricLabel(choroInfo.metric, choroInfo.perPopOn);
        const which = (choroInfo.geo === "wards") ? "Wards" : "ANCs";
        choroLegend =
          `<div class="muted">${which} shaded by <strong>${lbl}</strong>.</div>
           ${rampBlock(choroRamp, choroInfo.min, choroInfo.max, choroInfo.metric === "pct_closed" ? "%" : "")}`;
      }

      setLegendHTML(
	  `<div class="title">Legend</div>
	   <div class="section">
		 <div class="legendSectionTitle">Points</div>
		 ${pointsLegend}
	   </div>
	   <div class="section">
		 <div class="legendSectionTitle">Choropleth</div>
		 ${choroLegend}
	   </div>`
	);
	
	// Legend overlay (always visible, semi-transparent)
	const legendCtrl = L.control({ position: "bottomright" });
	legendCtrl.onAdd = () => {
	  const div = L.DomUtil.create("div", "legendOverlay");
	  div.id = "legendOverlay";
	  div.innerHTML = `<div class="title">Legend</div><div class="muted">Loading…</div>`;
	  L.DomEvent.disableClickPropagation(div);
	  L.DomEvent.disableScrollPropagation(div);
	  return div;
	};
	legendCtrl.addTo(map);

	function setLegendHTML(html) {
	  const el = document.getElementById("legendOverlay");
	  if (el) el.innerHTML = html;
	}

    // -------------------------
    // Debounced recompute
    // -------------------------
    let timer = null;
    function recompute() {
      clearTimeout(timer);
      timer = setTimeout(() => {
        // any time metric changes, per-pop validity might change
        validatePerPopToggle();
        clampSliders();

        const feats = filteredPoints();
        countPill.textContent = `Points: ${feats.length.toLocaleString()} / ${allPointsFC.features.length.toLocaleString()}`;
        startLabel.textContent = fmtDT(Number(startSlider.value));
        endLabel.textContent = fmtDT(Number(endSlider.value));

        const metric = metricSel.value;
        const pointMode = pointsUseTtcScale(metric) ? "ttc" : "status";

        let ttcMin = null, ttcMax = null;
        if (pointMode === "ttc") {
          const vals = feats
            .map(f => f.properties)
            .filter(p => p && p.closed === true && isNum(p.ttc_hours))
            .map(p => p.ttc_hours);
          if (vals.length) { ttcMin = Math.min(...vals); ttcMax = Math.max(...vals); }
        }

        updatePointLayer(feats, ttcMin, ttcMax);
        const choroInfo = updateChoropleth(feats);
        renderLegend({ pointMode, ttcMin, ttcMax, choroInfo });
      }, 60);
    }

    // -------------------------
    // Boot
    // -------------------------
    async function boot() {
      const refresh = await fetchJson("./data/last_refresh.json");
      setMeta(refresh);

      try { pops = await fetchJson("./data/populations.json"); }
      catch (e) { pops = null; console.warn("No populations.json loaded:", e.message); }

      allPointsFC = await fetchJson("./data/points.geojson");
      wardsBase = await fetchJson("./data/choropleth_wards.geojson");
      ancsBase = await fetchJson("./data/choropleth_ancs.geojson");

      const times = allPointsFC.features
        .map(f => f.properties?.add_ms)
        .filter(t => typeof t === "number" && isFinite(t));
      if (!times.length) throw new Error("No add_ms timestamps found in points.geojson");

      RANGE_MIN = Math.min(...times);
      RANGE_MAX = Math.max(...times);

      startSlider.min = String(RANGE_MIN);
      startSlider.max = String(RANGE_MAX);
      startSlider.step = String(RANGE_STEP);
      startSlider.value = String(RANGE_MIN);

      endSlider.min = String(RANGE_MIN);
      endSlider.max = String(RANGE_MAX);
      endSlider.step = String(RANGE_STEP);
      endSlider.value = String(RANGE_MAX);

      // scope->metric options
      applyScope();

      // listeners
      startSlider.addEventListener("input", recompute);
      endSlider.addEventListener("input", recompute);

      geoSel.addEventListener("change", () => { validatePerPopToggle(); recompute(); });
      showChoro.addEventListener("change", () => { validatePerPopToggle(); recompute(); });

      scopeSel.addEventListener("change", () => { applyScope(); validatePerPopToggle(); recompute(); });
      metricSel.addEventListener("change", () => { validatePerPopToggle(); recompute(); });

      perPop.addEventListener("change", () => { validatePerPopToggle(); recompute(); });
      showPoints.addEventListener("change", recompute);

      // presets
      presetAll.addEventListener("click", () => {
        startSlider.value = String(RANGE_MIN);
        endSlider.value = String(RANGE_MAX);
        recompute();
      });

      presetStorm.addEventListener("click", () => {
        // Jan 24 in Eastern time (standard time: -05:00)
        const stormStart = Date.parse("2026-01-24T00:00:00-05:00");
        const target = Math.max(RANGE_MIN, stormStart);

        // snap to hour step
        const snapped = Math.floor(target / RANGE_STEP) * RANGE_STEP;

        startSlider.value = String(snapped);
        endSlider.value = String(RANGE_MAX);
        recompute();
      });

      // initial render
      recompute();
    }

    boot().catch(err => {
      document.getElementById("meta").textContent = `Failed to load data files: ${err.message}`;
      console.error(err);
    });
  </script>
</body>
</html>
