<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DC311 Snow Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    header { padding: 12px 14px; border-bottom: 1px solid #eee; background: #fff; }
    h1 { font-size: 20px; margin: 0 0 6px; }
    #map { height: calc(100vh - 255px); }

    .row { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
    .small { font-size: 13px; color:#555; }
    label { font-size: 13px; color:#222; }
    select, input[type="checkbox"] { margin-left: 6px; }
    input[type="range"] { width: 240px; }

    .pill { padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; color:#333; background:#fafafa; }
    .legendBox { background:#fff; padding:8px 10px; border:1px solid #ddd; border-radius:10px; font-size:12px; }
    .legendTitle { font-weight: 700; margin-bottom: 4px; }
    .legendSection { margin-top: 8px; }
    .swatch { display:inline-block; width:12px; height:12px; vertical-align:middle; margin-right:6px; border:1px solid #bbb; }
    .legendRow { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .muted { color:#666; }
  </style>
</head>
<body>
  <header>
    <h1>DC311 Snow Dashboard</h1>
    <div class="row small" id="meta">Loading…</div>

    <div class="row" style="margin-top:10px;">
      <label>Choropleth:
        <select id="geo">
          <option value="none">None</option>
          <option value="wards" selected>Wards</option>
          <option value="ancs">ANCs</option>
        </select>
      </label>

      <label>Metric:
        <select id="metric">
          <option value="median_ttc_hours" selected>Median time-to-close (hrs)</option>
          <option value="mean_ttc_hours">Mean time-to-close (hrs)</option>
          <option value="pct_closed">% closed</option>
          <option value="open">Open count</option>
          <option value="closed">Closed count</option>
          <option value="total">Total requests</option>
        </select>
      </label>

      <label>Status:
        <select id="status">
          <option value="both" selected>Open + Resolved</option>
          <option value="open">Open only</option>
          <option value="resolved">Resolved only</option>
        </select>
      </label>

      <!-- Choropleth on/off -->
      <label class="pill">
        <input type="checkbox" id="showChoro" checked />
        Show choropleth
      </label>

      <!-- Per-pop (only appears when it applies AND choropleth is on) -->
      <span id="perPopWrap" class="pill" style="display:none;">
        <label style="cursor:pointer;">
          <input type="checkbox" id="perPop" />
          Per 10k residents
        </label>
      </span>

      <label class="pill">
        <input type="checkbox" id="showPoints" checked />
        Show points
      </label>

      <span class="pill" id="countPill">Points: —</span>
    </div>

    <div class="row" style="margin-top:10px;">
      <label>From:
        <input type="range" id="start" />
        <span class="small" id="startLabel">—</span>
      </label>
      <label>To:
        <input type="range" id="end" />
        <span class="small" id="endLabel">—</span>
      </label>
    </div>

    <!-- Legends in the header (white space), not on the map -->
    <div class="row" style="margin-top:10px;">
      <div id="legendBox" class="legendBox" style="width: 100%;"></div>
    </div>
  </header>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // -------------------------
    // Helpers
    // -------------------------
    const fmtDT = (ms) => {
      const d = new Date(ms);
      return d.toLocaleString(undefined, { year:"numeric", month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit" });
    };
    const isNum = (x) => typeof x === "number" && isFinite(x);

    function median(arr) {
      if (!arr.length) return null;
      arr.sort((a,b)=>a-b);
      const m = Math.floor(arr.length/2);
      return arr.length % 2 ? arr[m] : (arr[m-1] + arr[m]) / 2;
    }
    function mean(arr) {
      if (!arr.length) return null;
      let s = 0;
      for (const v of arr) s += v;
      return s / arr.length;
    }

    async function fetchJson(url) {
      const r = await fetch(url, { cache: "no-store" });
      if (!r.ok) throw new Error(`${url} HTTP ${r.status}`);
      return await r.json();
    }

    // Choropleth ramp (light -> dark blue)
    function choroRamp(t) {
      const colors = ["#f7fbff","#deebf7","#c6dbef","#9ecae1","#6baed6","#2171b5"];
      t = Math.max(0, Math.min(1, t));
      return colors[Math.min(colors.length - 1, Math.floor(t * colors.length))];
    }

    // Point scale ramp (blue -> red) for time-to-close
    function rbRamp(t) {
      const colors = ["#2166ac","#67a9cf","#d1e5f0","#fddbc7","#ef8a62","#b2182b"];
      t = Math.max(0, Math.min(1, t));
      return colors[Math.min(colors.length - 1, Math.floor(t * colors.length))];
    }

    // -------------------------
    // Metric rules
    // -------------------------
    const PER_POP_METRICS = new Set(["open", "closed", "total"]);
    const TTC_METRICS = new Set(["median_ttc_hours", "mean_ttc_hours"]);

    function metricSupportsPerPop(metric) {
      return PER_POP_METRICS.has(metric);
    }
    function pointsUseTtcScale(metric) {
      return TTC_METRICS.has(metric);
    }

    function metricLabel(metric, perPopOn) {
      const base = {
        median_ttc_hours: "Median time-to-close (hrs)",
        mean_ttc_hours: "Mean time-to-close (hrs)",
        pct_closed: "% closed",
        open: "Open count",
        closed: "Closed count",
        total: "Total requests",
      }[metric] ?? metric;

      if (perPopOn && metricSupportsPerPop(metric)) return `${base} (per 10k residents)`;
      return base;
    }

    function metricValue(m, metric, pop, perPopOn) {
      if (!m) return null;

      const derived = {
        pct_closed: () => isNum(m.pct_closed) ? (m.pct_closed * 100) : null,
        median_ttc_hours: () => m.median_ttc_hours,
        mean_ttc_hours: () => m.mean_ttc_hours,
      };

      if (derived[metric]) return derived[metric]();

      // counts
      const v = m[metric];
      if (!perPopOn || !metricSupportsPerPop(metric)) return v;

      if (!isNum(v) || !isNum(pop) || pop <= 0) return null;
      return (v / pop) * 10000.0;
    }

    function computeMetrics(points, keyField) {
      const groups = new Map();

      for (const f of points) {
        const p = f.properties || {};
        const k = p[keyField];
        if (!k) continue;

        let g = groups.get(k);
        if (!g) {
          g = { total:0, open:0, closed:0, pct_closed:null,
                median_ttc_hours:null, mean_ttc_hours:null, median_open_age_hours:null,
                _ttc:[], _age:[] };
          groups.set(k, g);
        }

        g.total += 1;

        if (p.closed === true) {
          g.closed += 1;
          if (isNum(p.ttc_hours)) g._ttc.push(p.ttc_hours);
        } else {
          g.open += 1;
          if (isNum(p.open_age_hours)) g._age.push(p.open_age_hours);
        }
      }

      const out = {};
      for (const [k, g] of groups.entries()) {
        g.pct_closed = g.total ? (g.closed / g.total) : null;
        g.median_ttc_hours = median(g._ttc);
        g.mean_ttc_hours = mean(g._ttc);
        g.median_open_age_hours = median(g._age);
        delete g._ttc; delete g._age;
        out[String(k)] = g;
      }
      return out;
    }

    // -------------------------
    // Map init
    // -------------------------
    const map = L.map('map', { preferCanvas: true }).setView([38.9072, -77.0369], 12);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    let allPointsFC = null;
    let wardsBase = null;
    let ancsBase = null;
    let pops = null; // optional populations.json

    let pointsLayer = null;
    let choroLayer = null;

    // -------------------------
    // UI elements
    // -------------------------
    const geoSel = document.getElementById("geo");
    const metricSel = document.getElementById("metric");
    const statusSel = document.getElementById("status");
    const showChoro = document.getElementById("showChoro");
    const perPop = document.getElementById("perPop");
    const perPopWrap = document.getElementById("perPopWrap");
    const showPoints = document.getElementById("showPoints");
    const startSlider = document.getElementById("start");
    const endSlider = document.getElementById("end");
    const startLabel = document.getElementById("startLabel");
    const endLabel = document.getElementById("endLabel");
    const countPill = document.getElementById("countPill");
    const legendBox = document.getElementById("legendBox");

    function setMeta(j) {
      document.getElementById("meta").textContent =
        `Last refresh (UTC): ${j.last_refresh_utc} · Records: ${j.records}`;
    }

    function clampSliders() {
      const a = Number(startSlider.value);
      const b = Number(endSlider.value);
      if (a > b) endSlider.value = startSlider.value;
    }

    function filteredPoints() {
      const a = Number(startSlider.value);
      const b = Number(endSlider.value);
      const mode = statusSel.value; // both | open | resolved

      return allPointsFC.features.filter(f => {
        const p = f.properties || {};
        const t = p.add_ms;
        if (typeof t !== "number" || !isFinite(t) || t < a || t > b) return false;

        const isClosed = (p.closed === true);
        if (mode === "open" && isClosed) return false;
        if (mode === "resolved" && !isClosed) return false;

        return true;
      });
    }

    // -------------------------
    // UI sync (this is the “intuitive guardrail”)
    // -------------------------
    function syncUI() {
      const metric = metricSel.value;

      // Choropleth controls enabled only if choropleth is on
      geoSel.disabled = !showChoro.checked;

      // per-pop only makes sense for choropleth + counts + geo != none
      const perPopOk =
        showChoro.checked &&
        geoSel.value !== "none" &&
        metricSupportsPerPop(metric);

      perPopWrap.style.display = perPopOk ? "" : "none";
      if (!perPopOk && perPop.checked) perPop.checked = false;
    }

    // -------------------------
    // Points layer (with auto coloring)
    // -------------------------
    function updatePointLayer(feats, ttcMin, ttcMax) {
      if (pointsLayer) pointsLayer.remove();

      if (!showPoints.checked) {
        pointsLayer = null;
        return;
      }

      const metric = metricSel.value;
      const useScale = pointsUseTtcScale(metric);

      const fc = { type: "FeatureCollection", features: feats };

      pointsLayer = L.geoJSON(fc, {
        pointToLayer: (feature, latlng) => {
          const p = feature.properties || {};
          const closed = p.closed === true;

          // Default status colors: open=red, resolved=blue
          let fill = closed ? "#1f77b4" : "#d62728";

          // When metric is median/mean ttc, color resolved points by their ttc_hours
          if (useScale && closed && isNum(p.ttc_hours) && isNum(ttcMin) && isNum(ttcMax) && ttcMax > ttcMin) {
            const t = (p.ttc_hours - ttcMin) / (ttcMax - ttcMin);
            fill = rbRamp(t);
          } else if (useScale && !closed) {
            // open requests don’t have ttc; keep them visible but muted
            fill = "#999999";
          }

          return L.circleMarker(latlng, {
            radius: 4,
            weight: 0.6,
            opacity: 0.9,
            fillOpacity: 0.75,
            fillColor: fill,
            color: "#222"
          });
        },
        onEachFeature: (feature, layer) => {
          const p = feature.properties || {};
          const created = (typeof p.add_ms === "number") ? fmtDT(p.add_ms) : "—";
          const isClosed = (p.closed === true);
          const resolvedAt = (typeof p.res_ms === "number") ? fmtDT(p.res_ms) : "—";

          const ward = p.WARD ?? "—";
          const anc = p.ANC_ID ?? "—";
          const addr = p.STREETADDRESS ?? "";
          const desc = p.SERVICECODEDESCRIPTION ?? "";

          const status = isClosed ? "Resolved" : "Open";

          const extra =
            isClosed && isNum(p.ttc_hours) ? `<br/>Time to close: ${p.ttc_hours.toFixed(1)} hrs`
            : (!isClosed && isNum(p.open_age_hours) ? `<br/>Open age: ${p.open_age_hours.toFixed(1)} hrs` : "");

          const html =
            `<strong>${status}</strong><br/>
             ${desc}<br/>
             ${addr}<br/>
             Ward ${ward} · ANC ${anc}<br/>
             Created: ${created}<br/>
             Resolved: ${isClosed ? "Yes" : "No"}${isClosed ? `<br/>Resolved at: ${resolvedAt}` : ""}${extra}`;

          layer.bindTooltip(html, { sticky: true });
          layer.bindPopup(html);
        }
      }).addTo(map);
    }

    // -------------------------
    // Choropleth layer (optional toggle)
    // -------------------------
    function updateChoropleth(feats) {
      if (choroLayer) choroLayer.remove();
      choroLayer = null;

      if (!showChoro.checked) return null;

      const geo = geoSel.value;
      if (geo === "none") return null;

      const metric = metricSel.value;
      const perPopOn = perPop.checked;

      const base = (geo === "wards") ? wardsBase : ancsBase;
      const keyField = (geo === "wards") ? "WARD" : "ANC_ID";
      const pointsKey = keyField;

      const popTable = (geo === "wards") ? (pops?.wards || {}) : (pops?.ancs || {});
      const mm = computeMetrics(feats, pointsKey);

      const gj = JSON.parse(JSON.stringify(base));
      for (const ft of gj.features) {
        const k = ft.properties?.[keyField];
        const id = (k != null) ? String(k) : null;

        ft.properties = ft.properties || {};
        ft.properties._m = (id && mm[id]) ? mm[id] : null;
        ft.properties._pop = (id && popTable[id] != null) ? Number(popTable[id]) : null;
      }

      const vals = [];
      for (const ft of gj.features) {
        const v = metricValue(ft.properties._m, metric, ft.properties._pop, perPopOn);
        if (isNum(v)) vals.push(v);
      }
      const min = vals.length ? Math.min(...vals) : 0;
      const max = vals.length ? Math.max(...vals) : 1;

      choroLayer = L.geoJSON(gj, {
        style: (feature) => {
          const v = metricValue(feature.properties?._m, metric, feature.properties?._pop, perPopOn);
          let fill = "#eee";
          if (isNum(v) && max > min) fill = choroRamp((v - min) / (max - min));
          return { color: "#333", weight: 1, fillColor: fill, fillOpacity: 0.75 };
        },
        onEachFeature: (feature, layer) => {
          const p = feature.properties || {};
          const m = p._m;
          const pop = p._pop;

          const name = (geo === "wards") ? `Ward ${p.WARD}` : `ANC ${p.ANC_ID}`;

          const v = metricValue(m, metric, pop, perPopOn);
          const shown = (metric === "pct_closed" && isNum(v)) ? `${v.toFixed(1)}%`
                      : (isNum(v) ? v.toFixed(1) : "n/a");

          const total = m?.total ?? 0;
          const open = m?.open ?? 0;
          const closed = m?.closed ?? 0;

          const popLine = isNum(pop) ? `Population: ${Math.round(pop).toLocaleString()}` : `Population: n/a`;

          layer.bindTooltip(
            `<strong>${name}</strong><br/>
             ${metricLabel(metric, perPopOn)}: ${shown}<br/>
             total: ${total} · open: ${open} · closed: ${closed}<br/>
             ${popLine}`,
            { sticky: true }
          );
        }
      }).addTo(map);

      return { geo, metric, perPopOn, min, max };
    }

    // -------------------------
    // Legend rendering (in header)
    // -------------------------
    function rampBlock(rampFn, min, max, unitSuffix="") {
      const steps = 6;
      if (!isNum(min) || !isNum(max) || max <= min) {
        return `<div class="muted">n/a</div>`;
      }
      let html = "";
      for (let i = 0; i < steps; i++) {
        const t0 = i / steps;
        const t1 = (i + 1) / steps;
        const mid = (t0 + t1) / 2;
        const a = (min + (max - min) * t0).toFixed(1);
        const b = (min + (max - min) * t1).toFixed(1);
        html += `<div><span class="swatch" style="background:${rampFn(mid)}"></span><span>${a}–${b}${unitSuffix}</span></div>`;
      }
      return html;
    }

    function renderLegend({ pointMode, ttcMin, ttcMax, choroInfo }) {
      const metric = metricSel.value;

      // Points legend
      let pointsLegend = "";
      if (!showPoints.checked) {
        pointsLegend = `<div class="muted">Points hidden</div>`;
      } else if (pointMode === "ttc") {
        pointsLegend =
          `<div class="small muted">Resolved points colored by <strong>time to close</strong> (hrs). Open points shown in gray.</div>
           ${rampBlock(rbRamp, ttcMin, ttcMax, " hrs")}`;
      } else {
        pointsLegend =
          `<div class="legendRow">
             <div><span class="swatch" style="background:#d62728"></span>Open</div>
             <div><span class="swatch" style="background:#1f77b4"></span>Resolved</div>
           </div>`;
      }

      // Choropleth legend
      let choroLegend = `<div class="muted">Choropleth off</div>`;
      if (choroInfo && showChoro.checked && geoSel.value !== "none") {
        const lbl = metricLabel(choroInfo.metric, choroInfo.perPopOn);
        const which = (choroInfo.geo === "wards") ? "Wards" : "ANCs";
        choroLegend =
          `<div class="small muted">${which} shaded by <strong>${lbl}</strong>.</div>
           ${rampBlock(choroRamp, choroInfo.min, choroInfo.max, choroInfo.metric === "pct_closed" ? "%" : "")}`;
      }

      legendBox.innerHTML =
        `<div class="legendTitle">Legend</div>
         <div class="legendSection">
           <div><strong>Points</strong></div>
           ${pointsLegend}
         </div>
         <div class="legendSection">
           <div><strong>Choropleth</strong></div>
           ${choroLegend}
         </div>`;
    }

    // -------------------------
    // Debounced recompute
    // -------------------------
    let timer = null;
    function recompute() {
      clearTimeout(timer);
      timer = setTimeout(() => {
        syncUI();
        clampSliders();

        const feats = filteredPoints();
        countPill.textContent = `Points: ${feats.length.toLocaleString()} / ${allPointsFC.features.length.toLocaleString()}`;
        startLabel.textContent = fmtDT(Number(startSlider.value));
        endLabel.textContent = fmtDT(Number(endSlider.value));

        // If metric is median/mean ttc, color resolved points by their own ttc_hours
        const metric = metricSel.value;
        const pointMode = pointsUseTtcScale(metric) ? "ttc" : "status";

        let ttcMin = null, ttcMax = null;
        if (pointMode === "ttc") {
          const vals = feats
            .map(f => f.properties)
            .filter(p => p && p.closed === true && isNum(p.ttc_hours))
            .map(p => p.ttc_hours);

          if (vals.length) {
            ttcMin = Math.min(...vals);
            ttcMax = Math.max(...vals);
          }
        }

        updatePointLayer(feats, ttcMin, ttcMax);
        const choroInfo = updateChoropleth(feats);

        renderLegend({ pointMode, ttcMin, ttcMax, choroInfo });
      }, 75);
    }

    // -------------------------
    // Boot
    // -------------------------
    async function boot() {
      const refresh = await fetchJson("./data/last_refresh.json");
      setMeta(refresh);

      // populations.json is optional, but needed for per-pop
      try {
        pops = await fetchJson("./data/populations.json");
      } catch (e) {
        pops = null;
        console.warn("No populations.json loaded:", e.message);
      }

      allPointsFC = await fetchJson("./data/points.geojson");
      wardsBase = await fetchJson("./data/choropleth_wards.geojson");
      ancsBase = await fetchJson("./data/choropleth_ancs.geojson");

      const times = allPointsFC.features
        .map(f => f.properties?.add_ms)
        .filter(t => typeof t === "number" && isFinite(t));

      if (!times.length) throw new Error("No add_ms timestamps found in points.geojson");

      const minT = Math.min(...times);
      const maxT = Math.max(...times);

      const STEP = 3600 * 1000; // 1 hour

      startSlider.min = String(minT);
      startSlider.max = String(maxT);
      startSlider.step = String(STEP);
      startSlider.value = String(minT);

      endSlider.min = String(minT);
      endSlider.max = String(maxT);
      endSlider.step = String(STEP);
      endSlider.value = String(maxT);

      // wire UI
      startSlider.addEventListener("input", recompute);
      endSlider.addEventListener("input", recompute);

      geoSel.addEventListener("change", () => { syncUI(); recompute(); });
      metricSel.addEventListener("change", () => { syncUI(); recompute(); });

      statusSel.addEventListener("change", recompute);
      showChoro.addEventListener("change", () => { syncUI(); recompute(); });
      perPop.addEventListener("change", recompute);
      showPoints.addEventListener("change", recompute);

      // initial render
      syncUI();
      recompute();
    }

    boot().catch(err => {
      document.getElementById("meta").textContent = `Failed to load data files: ${err.message}`;
      console.error(err);
    });
  </script>
</body>
</html>
